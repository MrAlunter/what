// code from saturday the 28/05.
// using btn states machine in playback, cant reacsess loop once exited?????


#include <avr/io.h>
#include <util/delay.h>
#include <stdio.h>
#include <stdint.h>
#include <avr/interrupt.h>
#include "uart.h"
#include "timer.h"
#include "buzzer.h"
#include "spi.h"
#include "buttons.h"
#include "sequence_gen.h"
#include "adc.h"

typedef enum // enum for state machine
{
    maker,
    playback,
    btn1,
    btn2,
    btn3,
    btn4,
    wait,
    wait_input,
    checker,

} states; // enum for state machine

uint8_t num;
uint32_t STATE_LSFR = 0x11271965;
volatile uint8_t message = 0;
void print_rand(uint16_t *value)
{
    uint8_t STEP = *value;
    STEP = STEP & 0b11;
    switch (STEP)
    {
    case (0b00):
        num = 1;
        break;
    case (0b01):
        num = 2;
        break;
    case (0b10):
        num = 3;
        break;
    case (0b11):
        num = 4;
        break;
    }
}
uint32_t next(void)

{
    uint32_t BIT = STATE_LSFR & 0x01;
    STATE_LSFR >>= 1;

    if (BIT == 1)
    {
        STATE_LSFR ^= 0xEC2023CAB;
    }

    return STATE_LSFR;
}
volatile uint8_t tplay = 0;
volatile uint32_t current_time = 0;
uint32_t start_time = 0;
uint8_t pb_previous = 0xFF;
uint8_t pb_current = 0xFF;
volatile uint8_t pb_state = 0xFF;
void main(void)
{
    cli();           // Disable interrupts
    uart_init();     // Initialise UART (serial port)
    timer_init();    // Initialise timer (for UART)
    buzzer_init();   // Initialise buzzer (PWM)
    buttons_init();  // Initialise buttons (for user input)
    spi_init();      // Initialise SPI
    spi_write(0xFF); // Clear SPI (MOSI) buffer
    uart_init();     // Initialize the UART (serial port)
    adc_init();      // Initialize ADC
    // PORTB.OUTSET = PIN2_bm; // UART thing :) (I think)
    TCB0.INTCTRL = TCB_CAPT_bm; // Enable interrupts for TCB0
    sei();                      // Enable interrupts
    uint32_t seqe[1000];        // Array to store the sequence
    uint8_t round_count = 0;    // Variable to store the current round
    states state = maker;       // Initial state
    uint8_t index = 0;          // Variable to store the current index of the sequence
    uint8_t game = 0;           // Variable to store if the game is running or not
    uint8_t guess;              // Variable to store the current guess
    uint8_t counted = 0;        // Variable to store if the current round has been counted
    uint8_t finished = 0;       // Variable to store if the current round has been finished
    uint8_t game_over = 0;      // Variable to store if the game is over

    while (1)
    {
        uint8_t pb_changed = pb_current ^ pb_previous; // Check if any buttons have changed
        uint8_t pb_falling = pb_changed & pb_previous; // Check if any buttons are falling
        pb_previous = pb_current;                      // Update the previous button state
        pb_current = pb_state;                         // Update the current button state
        switch (state)
        {
        case maker:
        {
            uart_puts("Playing Maker...\n"); // Print the current state
            uint16_t random_number = next(); // Generate a random number
            print_rand(&random_number);      // Print the random number
            seqe[round_count] = num;         // Add the new element to the sequence
            state = playback;                // Change the state to playback
            break;
        }

        case playback:
        {
            uart_puts("Playing Sequence...\n"); // Print the current state

            uart_puts("seq loop\n");
            for (uint8_t i = 0; i < (round_count + 1); i++)
            {
                switch (seqe[i])
                {
                case 1:

                    state = btn1;
                    break;

                case 2:

                    state = btn2;
                    break;

                case 3:

                    state = btn3;
                    break;

                case 4:

                    state = btn4;
                    break;
                }
            }
            break;
        }
        case wait_input:
        {
            if (counted > round_count)
            {
                uart_puts("Congratulations you made it\n");
                uart_puts("New Round Starting...\n");
                tplay = 6;
                counted = 0;
                game = 0;
                round_count++;
                finished = 1;
                if (finished == 1)
                {
                    start_time = current_time;
                }
                state = wait;
                break;
            }
            if (counted <= round_count)
            {
                game = 1;
                guess = 0;
                uart_puts("Waiting Input\n");
                if (pb_falling & PIN4_bm)
                {
                    state = btn1;
                }
                if (pb_falling & PIN5_bm)
                {
                    state = btn2;
                }
                if (pb_falling & PIN6_bm)
                {
                    state = btn3;
                }
                if (pb_falling & PIN7_bm)
                {
                    state = btn4;
                }
                break;
            }
        }

        case btn1:
        {

            uart_puts("btn1\n");

            start_time = current_time;
            TCA0.SINGLE.PER = 9487;
            TCA0.SINGLE.CMP0 = 4744;
            PORTB.DIRSET = PIN0_bm;
            tplay = 1; // set which tone is playing
            if (game == 1)
            {
                guess = 1;
            }
            state = wait;

            break;
        }

        case btn2:
        {
            uart_puts("btn2\n");
            TCA0.SINGLE.PER = 11288;
            TCA0.SINGLE.CMP0 = 5644;
            PORTB.DIRSET = PIN0_bm;
            tplay = 2; // set which tone is playing
            if (game == 1)
            {
                guess = 2;
            }
            start_time = current_time;
            state = wait;
            break;
        }

        case btn3:
        {

            uart_puts("btn3\n");
            TCA0.SINGLE.PER = 12654;
            TCA0.SINGLE.CMP0 = 6327;
            PORTB.DIRSET = PIN0_bm;
            tplay = 3; // set which tone is playing
            if (game == 1)
            {
                guess = 3;
            }
            start_time = current_time;
            state = wait;
            break;
        }

        case btn4:
        {

            uart_puts("btn4\n");

            TCA0.SINGLE.PER = 14242;
            TCA0.SINGLE.CMP0 = 7121;
            PORTB.DIRSET = PIN0_bm;
            tplay = 4; // set which tone is playing
            if (game == 1)
            {
                guess = 4;
            }
            start_time = current_time;
            state = wait;
            break;
        }

        case wait:
        {
            uart_puts("Waiting Normally\n");
            if ((current_time - start_time) >= 100)
            {
                if ((current_time - start_time) >= (100 >> 2))
                {

                    uart_puts("Buzzer Off\n");
                    PORTB.DIRCLR = PIN0_bm;
                    start_time = 0;
                    tplay = 0;
                }
                if (game == 1)
                {
                    state = checker;
                }

                else if (game != 1)
                {
                    if (finished == 1)
                    {
                        uart_puts("FINISHED\n");
                        state = maker;
                        finished = 0;
                    }
                    if (game_over == 1)
                    {
                        uart_puts("GAME OVER\n");
                        state = maker;
                        game_over = 0;
                    }
                    if (index != round_count)
                    {
                        state = playback;
                        index++;
                    }
                    else if (index == round_count)
                    {
                        game = 1;
                        state = wait_input;
                    }
                }
            }

            break;
        }
        case checker:
        {
            uart_puts("Check\n");
            if (counted <= round_count)
            {
                if (guess != seqe[counted])
                {
                    uart_puts("Give up, Get the soldering iron\n"); // Print the game over message
                    game = 0;
                    counted = 0;
                    for (uint8_t i = 0; i < round_count; i++)
                    {
                        seqe[i] = 0;
                    }
                    round_count = 0;
                    game_over = 1;
                    if (game_over == 1)
                    {
                        start_time = current_time;
                    }
                    tplay = 7;
                    state = wait;
                }
                if (guess == seqe[counted])
                {
                    uart_puts("Correct\n");
                    counted++;
                    state = wait_input;
                    guess = 0;
                }
            }
            break;
        }
        }
    }
}

ISR(TCB0_INT_vect)
{
    current_time++;

    static uint8_t count0 = 0;
    static uint8_t count1 = 0;

    uint8_t pb_sample = PORTA.IN;
    uint8_t pb_changed = pb_sample ^ pb_state;

    count1 = (count1 ^ count0) & pb_changed;
    count0 = ~count0 & pb_changed;

    pb_state ^= (count1 & count0) | (pb_changed & pb_state);

    static uint8_t side = 0;
    switch (tplay)
    {
    case 0: // Clears display
        if (side == 0)
            spi_write(0xFF);
        else
            spi_write(0xFF);
        break;
    case 1:
        if (side == 0)
            spi_write(0b10111110);
        else
            spi_write(0b01111111);
        break;
    case 2:
        if (side == 0)
            spi_write(0b01111111);
        else
            spi_write(0b11101011);
        break;
    case 3:
        if (side == 0)
            spi_write(0b00111110);
        else
            spi_write(0b11111111);
        break;
    case 4:
        if (side == 0)
            spi_write(0b01101011);
        else
            spi_write(0b11111111);
        break;
    case 5:
        if (side == 0)
            spi_write(0b01101011);
        else
            spi_write(0b10100111);
        break;
    case 6:
        if (side == 0)
            spi_write(0b00000000);
        else
            spi_write(0b10000000);
        break;
    case 7:
        if (side == 0)
            spi_write(0b01110111);
        else
            spi_write(0b11110111);
    }
    side = !side;
    TCB0.INTFLAGS = TCB_CAPT_bm;
}
